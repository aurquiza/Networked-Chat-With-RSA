/*
 *  This class will compute The RSA algorithm for every user that connects
 *  to the server chat program. Every user will have their own private and public key
 *  
 *  Note: - implementation for block sizes is still undecided, which will determine the minimum product size
 *          of two prime numbers
 *        - Primality test still not implemented. currently researching the best algorithm that is computationally fast
 *          and not incredibly difficult to code.
 */
package Securitypkg;

import java.math.BigInteger;

public class RSA
{
	// numbers that must be prime
	private BigInteger p;
	private BigInteger q;
	
	// computed using the values p and q 
	private BigInteger n;
	private BigInteger m;
	
	// computed using m
	private BigInteger e;
	private BigInteger d;
	
	// private and public keys generated by the RSA algorithm
	private PublicKey pubKey;
	private PrivateKey privKey;
	
	//encryption and decryption blocks
	
	
	//constructor
	// @Param p - passed in to compute rsa algorithm, must be prime
	// @Param q - passed in to compute rsa algorithm, must be prime
	public RSA(BigInteger p, BigInteger q)
	{
		this.q = q;
		this.p = p;
		
		n = p.multiply(q);
		
		// m = (p - 1) * (q- 1)
		m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));
		
		e = findFirstE();
		d = findD();
		
		pubKey = new PublicKey(n, e);
		privKey = new PrivateKey(n, d);
	}
	
	// This attempts to find a potential 'e' for the RSA algorithm 
	// where the gcd for e and m is 1.
	private BigInteger findFirstE()
	{
		// make object that will compute gcd
		EuclidianAlgorithm ea = new EuclidianAlgorithm(BigInteger.valueOf(2), m);
		ea.computeGCD();
		BigInteger gcd = ea.getGCD();
		
		// initialize potentialE
		BigInteger potentialE = BigInteger.valueOf(2);
		
		// loop until the gcd for e and m is 1
		// gcd != 1
		while(!gcd.equals(BigInteger.valueOf(1)))
		{
			potentialE = potentialE.add(BigInteger.valueOf(1));
			
			ea.setNewNumbers(potentialE, m);
			ea.computeGCD();
			gcd = ea.getGCD();
		}
		
		return potentialE;
	}
	
	// computes the value for D by continually looping and incrementing until the equation
	// equals 0 meaning the value 'k' managed to make the equation divisible by e
	// @Return returns the 'd' value needed for the algorithm
	private BigInteger findD()
	{
		BigInteger potentialK = BigInteger.valueOf(0);
		BigInteger potentialD = BigInteger.valueOf(-1);
		
		// (1 + k*m) % e  != 0
		while(!((((potentialK.multiply(m)).add(BigInteger.ONE)).mod(e)).equals(BigInteger.ZERO)))
			potentialK = potentialK.add(BigInteger.valueOf(1));
		
		
		potentialD = ((potentialK.multiply(m)).add(BigInteger.valueOf(1))).divide(e);
		
		return potentialD;
	}
	
	public BigInteger encryptM()
	{
		BigInteger encryptedBlock = BigInteger.ONE;
		
		return encryptedBlock;
	}
	
	
	// returns public key as an integer array of size 2
	public BigInteger[] getPubKey()
	{
		BigInteger publicKey[] = new BigInteger[]{pubKey.getN(),pubKey.getE()};
		return publicKey;
	}
	
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	// 					Methods mainly used for JUnit testing
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	
	public BigInteger getPVal()
	{
		return p;
	}
	
	public BigInteger getQVal()
	{
		return q;
	}
	
	public BigInteger getNVal()
	{
		return n;
	}
	
	public BigInteger getMVal()
	{
		return m;
	}
	
	public BigInteger getE()
	{
		return e;
	}
	
	public BigInteger getDVal()
	{
		return d;
	}
	
	public static BigInteger getGCD(BigInteger num1, BigInteger num2)
	{
		EuclidianAlgorithm e = new EuclidianAlgorithm(num1, num2);
		e.computeGCD();
		return e.getGCD();
	}
	
}
