/*
 *  This class will compute The RSA algorithm for every user that connects
 *  to the server chat program. Every user will have their own private and public key
 *  
 *  Note: - implementation for block sizes is still undecided, which will determine the minimum product size
 *          of two prime numbers
 *        - Primality test still not implemented. currently researching the best algorithm that is computationally fast
 *          and not incredibly difficult to code.
 */
package Securitypkg;

import java.math.BigInteger;
import java.util.*;


public class RSA
{
	// numbers that must be prime
	private BigInteger p;
	private BigInteger q;
	
	// computed using the values p and q 
	private BigInteger n;
	private BigInteger m;
	
	// computed using m
	private BigInteger e;
	private BigInteger d;
	
	// private and public keys generated by the RSA algorithm
	private PublicKey pubKey;
	private PrivateKey privKey;
	
	// validity check for caller of the object
	private boolean validPrimes = false;
	
	
	//constructor
	// @Param p - passed in to compute rsa algorithm, must be prime
	// @Param q - passed in to compute rsa algorithm, must be prime
	public RSA(BigInteger p, BigInteger q)
	{
		this.q = q;
		this.p = p;
		
		n = p.multiply(q);
		
		// m = (p - 1) * (q- 1)
		m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));
		
		e = findFirstE();
		d = findD();
		
		pubKey = new PublicKey(n, e);
		privKey = new PrivateKey(n, d);
	}
	
	
	
	// This attempts to find a potential 'e' for the RSA algorithm 
	// where the gcd for e and m is 1.
	private BigInteger findFirstE()
	{
		// make object that will compute gcd
		EuclidianAlgorithm ea = new EuclidianAlgorithm(BigInteger.valueOf(2), m);
		ea.computeGCD();
		BigInteger gcd = ea.getGCD();
		
		// initialize potentialE
		BigInteger potentialE = BigInteger.valueOf(2);
		
		// loop until the gcd for e and m is 1
		// gcd != 1
		while(!gcd.equals(BigInteger.valueOf(1)))
		{
			potentialE = potentialE.add(BigInteger.valueOf(1));
			
			ea.setNewNumbers(potentialE, m);
			ea.computeGCD();
			gcd = ea.getGCD();
		}
		
		return potentialE;
	}
	
	// computes the value for D by continually looping and incrementing until the equation
	// equals 0 meaning the value 'k' managed to make the equation divisible by e
	// @Return returns the 'd' value needed for the algorithm
	private BigInteger findD()
	{
		BigInteger potentialK = BigInteger.valueOf(0);
		BigInteger potentialD = BigInteger.valueOf(-1);
		
		// (1 + k*m) % e  != 0
		while(!((((potentialK.multiply(m)).add(BigInteger.ONE)).mod(e)).equals(BigInteger.ZERO)))
			potentialK = potentialK.add(BigInteger.valueOf(1));
		
		
		potentialD = ((potentialK.multiply(m)).add(BigInteger.valueOf(1))).divide(e);
		
		return potentialD;
	}
	
	public Vector<BigInteger> encryptM(String msg)
	{	
		// initialize variables for 
		int asciiVer[] = new int[msg.length()];
		Vector <BigInteger> block = new Vector<BigInteger>();
		BigInteger total = BigInteger.ZERO;
		int i = 0;
		
		for(i = 0; i < msg.length(); i++)
			asciiVer[i] = (int) msg.charAt(i);
		
		
		for(i = 0; i < asciiVer.length; i++)
		{
			BigInteger calculation = ( BigInteger.valueOf(asciiVer[i]) ).multiply( ( BigInteger.valueOf(128) ).pow(i % 4) );
			
			
			if( (i != 0) && (i % 4 == 0) )
			{
				block.add(total);
				total = BigInteger.ZERO;
				total = total.add(calculation);
			}
			else
			{
				total = total.add(calculation);
			}
		}
		
		if(i-1 % 4 != 0)
			block.add(total);
		
//		System.out.println("Inside encode method");
//		for(i = 0; i < block.size(); i++)
//			System.out.println(block.elementAt(i));
		
		for(int j = 0; j < block.size(); j++)
		{
			 BigInteger b = block.elementAt(j);
			 BigInteger encodedBlock = b.modPow(e, n);
			 block.set(j, encodedBlock);
		}

//		for(i = 0; i < block.size(); i++)
//			System.out.println(block.elementAt(i));
			
		return block;
	}
	
	public String decryptM(Vector<BigInteger> encryptedBlock)
	{
//		System.out.println("Inside decode method");
		String decryptedMessage = "";
		
		// initialize values that will be used for bit masking to get characters back
		BigInteger sevenBits = BigInteger.valueOf(0x7F);
		
		// decode the blocks
		for(int i = 0; i < encryptedBlock.size(); i++)
		{
			BigInteger b = encryptedBlock.elementAt(i);
			BigInteger db = b.modPow(d, n);
			encryptedBlock.set(i, db);
		}
		
		// undo the blocking algorithm done by encryption method and extract the characters
		for(int i = 0; i < encryptedBlock.size(); i++)
		{
			String fourChars = "";
			BigInteger chosenBlock = encryptedBlock.elementAt(i);
			
			// iterate 4 times because thats how many chars are in each block
			for(int j = 0; j < 4; j++)
			{
				BigInteger shiftedBits = sevenBits.shiftLeft(j*7);
				BigInteger savedBits = chosenBlock.and(shiftedBits);
				
				savedBits = savedBits.shiftRight(j*7);
				int extractedInt = savedBits.intValue();
				fourChars = fourChars + (char) extractedInt;
			}
			
			decryptedMessage = decryptedMessage.concat(fourChars);
		}
		
		//System.out.println(decryptedMessage);
		return decryptedMessage;
	}
	
	// returns public key as an integer array of size 2
	public BigInteger[] getPubKey()
	{
		BigInteger publicKey[] = new BigInteger[]{pubKey.getN(),pubKey.getE()};
		return publicKey;
	}
	
	// returns true if values passed into constructor passed the primality test
	// returns false if values passed failed the primality test
	public boolean isInputValid()
	{
		return false;
	}
	
	
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	// 					Methods mainly used for JUnit testing
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	
	public BigInteger getPVal()
	{
		return p;
	}
	
	public BigInteger getQVal()
	{
		return q;
	}
	
	public BigInteger getNVal()
	{
		return n;
	}
	
	public BigInteger getMVal()
	{
		return m;
	}
	
	public BigInteger getE()
	{
		return e;
	}
	
	public BigInteger getDVal()
	{
		return d;
	}
	
	public static BigInteger getGCD(BigInteger num1, BigInteger num2)
	{
		EuclidianAlgorithm e = new EuclidianAlgorithm(num1, num2);
		e.computeGCD();
		return e.getGCD();
	}
	
}
